FORMAT: 1A
HOST: https://api.test.bitmark.com/v1/

# Bitmark Core API 

## Overview

Bitmark makes simple tools that empower anyone to assert ownership over their digital lives. Although digital assets increasingly constitute what we create and value most in our lives, there is no way for individuals to claim ownership of them. By building a universal digital property system, Bitmark envisions a world in which everyone owns a piece of the digital economy. 

The Bitmark Core API is an open REST API that enables creation, transfer, and authentication of digital properties in the Bitmark property system. The Core API's simplified interface allows developers to easily build on the core Bitmark infrastructure by reading from and writing to the open-source Bitmark blockchain.

### What is property? 

In the physical world, property has long been governed by the formula: 

> **property = asset + title**

While most people probably consider property to be the stuff that they own, **property is technically defined as the rules governing access to and control of assets**, whether those assets are land, means of production, inventions, or other creative works. A **property title** is the legal instrument by which an entity claims ownership of an asset. Property titles are often embodied in a formal legal document, such as a real estate deed or a motor vehicle title, which serve as physical evidence of the possessor’s claim to property rights.You do not legally own a home unless you also hold the property title to that home. You do not legally own a car unless you also hold title to that car. Within every society, laws known as **property rights** regulate which entities can assert ownership claims to which assets and what rights accompany such claims:

![property rights](https://github.com/bitmark-inc/bitmark-core-doc/blob/master/property.png?raw=true)

A primary function of a property title is to make property rights portable by acting as a "container" that allows property rights to be transferred from one owner to another. For assets that require a property title, transfers of title must be publicly recorded via a centralized government entity, such as a county land registrar or a state department of motor vehicles, in order for the transfer of property rights to be legally recognized. This history of title transfer, or **provenance**, is most often tracked via a formal **property system**, which records the complete ownership history of every property registered in the system:

![property system](https://github.com/bitmark-inc/bitmark-core-doc/blob/master/property_system.png?raw=true)

### What is the Bitmark property system? 

The Bitmark property system is a universal property system for conferring the same property rights to digital assets that have long existed for physical assets. This system records ownership claims for digital assets as digital property titles known as **bitmarks**. Thus, in the digital world:

> **digital property = digital asset + bitmark** 

To enable this recording of property titles across the full depth and breadth of the Internet, Bitmark supplements existing methods for tracking provenance with a universally accessible property ledger known as the **Bitmark blockchain**. Blockchain technology is the key innovation of the [Bitcoin currency](https://bitcoin.org/bitcoin.pdf) and refers to a digital ledger that is publicly yet anonymously shared to all members of a peer-to-peer network. The Bitmark blockchain contains every single property title and ownership transfer ever recorded in the Bitmark system. This Internet-native ownership registry allows the Bitmark system to satisfy all the functional requirements of conventional property systems in a single, low-cost public data resource:

![Bitmark system](https://github.com/bitmark-inc/bitmark-core-doc/blob/master/bitmark_system.png?raw=true)

Unlike conventional property systems that rely on a handful of trusted government officials to act as centralized gatekeepers, the Bitmark blockchain is an open and transparent property system that is strengthened through the active participation of anyone on the Internet. The integrity of Bitmark’s open-source blockchain is secured by a peer-to-peer network of voluntary participants running the [Bitmark node software](https://bitmark.com/tools-api/node) called **bitmarkd**. These software nodes are incentivized to participate in verifying Bitmark property transactions through the possibility of winning monetary and property rewards. This strategy of rewarding an open network of peers for competitively verifying the results of one another’s work creates an impregnable security model that is an emergent property of the individual peer interactions themselves. Unlike centralized property systems, which suffer from increased negative externalities as larger populations exploit the shared resource, Bitmark’s decentralized blockchain grows more resilient and valuable as the network grows. The resulting system achieves extremely low transaction costs by supplanting conventional centrally controlled property systems with a secure distributed ledger for recording digital property titles for any digital asset.


## Version & Base URL 

This document refers to the current version of the Bitmark Core API, which is identified as: 

```
v1.0
```

All URLs referenced in this document have the following base URL:

```
https://api.test.bitmark.com/v1/
```
The Bitmark Core API is served over the [HTTPS protocol](https://en.wikipedia.org/wiki/HTTPS) to ensure data privacy and security. Unencrypted HTTP requests are not supported. 


## Accounts

Within the Bitmark system, an **account** represents any entity capable of creating and owning property, whether individuals, insitutions, or organizations. At the level of the Bitmark blockchian and Core API, accounts do not exist as native standalone objects but instead are found as attribute values in each of the 3 types of blockchain records (asset records, bitmark issuance records, and bitmark transfer records) or as digital signatures appended to each of these record types. Within the Bitmark system, an account is represented by a [public-private keypair](https://en.wikipedia.org/wiki/Public-key_cryptography). The Bitmark system currently uses the [Ed25519 signature scheme](https://ed25519.cr.yp.to/) to generate account keypairs. Each keypair is the combination of 32-random-byte seed (or private key) and a corresponding 32-byte public key.

### Public keys

An account's public key serves as a pseudonymous identifier within the Bitmark blockchain and is often referred to as a **Bitmark account naumber**. The Bitmark account number designates ownership by serving as the account value in each of the following blockchain record fields: 

- as the `registrant` parameter of an [asset record](#registering-an-asset)
- as the `owner` parameter of a bitmark [issuance record](#issuing-a-bitmark)
- as the `owner` parameter of a bitmark [transfer record](#transferring-a-bitmark)

A 32-byte Bitmark public key is constructed as follows:

1. Key varint value (keyVarint)
    - `1` bit determines the key part (public key = `0x01`)
    - `1` bit determines the network value (livenet = `0`, testnet = `1`)
    - `2` zero bit buffer
    - up to `60` bits determines the key type algorithm
2. Public key
3. Checksum — `sha3_256(varint(keyVariant) + pubkey).slice(0, 4)`

### Private keys

An account's private key is required to digitally sign any Bitmark blockchain record on behalf of that account, including asset records, bitmark issuance records, and bitmark transfer records. 

A Bitmark private key is constructed as follows:

1. Key varint value (keyVarint)
    - `1` bit determines the key part (private key = `0x00`)
    - `1` bit determines the network value (livenet = `0`, testnet = `1`UP)
    - `2` zero bit buffer
    - up to `60` bits determines the key type algorithm
2. Private key
3. Checksum — `sha3_256(varint(keyVariant) + pubkey).slice(0, 4)`

### Varint encoding

Varint encoding is a method to encode 64-bit numbers according to these rules:

- A number will be represented with up to 9 bytes.
- Each byte only represents the value from `0x01` to `0x7F` (meaning that we do not use the most significant bit to store the value) except for the 9th byte
- The most significant bit of the 1st to 8th bytes depends on whether we should concatenate the bits:
    - `1` means we should concatenate the bits
    - `0` means that the byte is the last one
- For the 9th byte (last byte), the most significant bit is also added to the value

**Example**

```
varint(10100100) = 00000001 1010 0100
varint(00000001 10101111 10110100 10111111 10100101 10111100 10101110 10101100) = 11010111 11101101 10010111 11111010 10101101 11110010 11011101 10101100
```

### Appending data to a binary chunk

**Appending a String Value**

```
varint(data) + buffer(data)
```

**Appending a Binary Value**

```
varint(data) + buffer(data)

```


# Group Assets

An **asset** is any digital object, including files, applications, code, and data. Assets are registered in the Bitmark system for the purpose of issuing bitmarks for them. Issuing a bitmark for an asset creates a digital property with a permananent reference to the underlying asset. This permananent link between bitmark issuance records and asset records allows any bitmark and asset to be authenticated into perpetuity. Multiple bitmarks can be issued for the same asset, thereby creating different properties from the same digital object. 

This section of the Bitmark Core API describes the objects and methods for registering and querying for assets in the Bitmark system. 

## Asset Registration Policy

As a means for avoiding data duplication and thereby minimizing blockchain size, assets can only be registered once in the Bitmark blockchain. Every time an asset record is submitted to the Bitmark network, the bitmarkd nodes check the asset record's `fingerprint` and `id` fields to determine whether the asset record already exists in the blockchain. If the asset record doesn't exist, the record is added to current block of the blockchain and a reference is returned to the new asset record. However, if an asset record with the same asset `id` already exists, the asset record is rejected from the blockchain and a reference is returned to the original asset record. 

One implication of this policy is that only the original assset record for an asset is allowed to determine the `name` and `metadata` fields for that asset record as well as all bitmarks issued for that asset. While other Bitmark accountholders can still issue bitmarks for the original asset record (not only the original asset `registrant`), these bitmark issuers cannot alter the bimtark name and metadata fields for their bitmarks since these fields are permanent attributes of the original underlying asset record. 

## Registering an asset

### PARAMETERS 

| PARAMETER  | TYPE  | DESCRIPTION  |
|---:|---|---|
| `fingerprint`  | string <br> **required** | Value representing the unique cryptographic hash of the asset. Maximum length is 1,024 Unicode characters. |
| `id` | string <br> **required** | [SHA3-512 hash](https://en.wikipedia.org/wiki/SHA-3) (64 bytes) of the `fingerprint` value, which guarantees a consistent `id` size regardless of the original size of the `fingerprint`. The `id` serves as a unique identifier for the asset and will be identical across all bitmark issuances for the same asset. |
| `name` | string <br> **required** | The name of the asset. Maximum length is 64 Unicode characters. |
| `metadata` | string <br> *optional* | A key-value dictionary represented by a maximum 1,024 Unicode characters string with the following format: `[key][separator][value][separator][key][separator][value]`with the Unicode character `0x0000` as the separator token.|
| `registrant` | string <br> **required** | Public key ([Ed25519](https://ed25519.cr.yp.to/)) of the accountholder registering the asset. |
| `signature` | binary <br> **required** | binary value (address without checksum) ??? |

Assets are registered according to a 3-step process:

1. The binary format of an Asset Record is packed for signing by concatenating the Asset Record attribute values in the following order:
    
    1. `varint(0x02)` — binary value prefix that identifies the record as an Asset Record
    2. `name` — string value
    3. `id` ** no longer called `AssetIndex` ???
    3. `fingerprint` — string value
    4. `metadata` — string value
    5. `registrant` — binary value (address without checksum)
2. The registering account must sign the packed record with the account's private key to create a valid `signature`. 
3. A payload is generated by appending the `signature` from Step 2 to the end of the packed Asset Record from Step 1.

The asset database record is returned as the result of API request which has more details about the assets. (***what to do with this?***)

- is there a method for submitting ... or?

## Querying for a specific asset [GET /assets/{asset_id}]

#### PARAMETERS 

| PARAMETER  | TYPE  | DESCRIPTION  |
|---:|---|---|
| `id`  | string <br> **required** | Sha3_256 hash of the asset `fingerprint`. |

+ Parameters

    + asset_id: 2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e (string, required) - ID of the asset

+ Request

        + asset_id: 2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e

+ Response 200 (application/json)

        {
            "asset": {
                "id": "2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e",
                "name": "all rise",
                "fingerprint": "013a13f34c7bd7ddd970c26d8ee6eea8685362554189219f2dc2833e6f5e1347e9d35365ad8bc71023d9d67acbee8060e9da40bac094193353b6546367b85193cc",
                "metadata": {
                "Creator": "ai biet"
                },
                "registrant": "e3iQ86Hdj8owb8xg31QqUqanptPoQLzt2UvXQ5CB2Jf5wyRKLk",
                "signature": "2488af1e00a6a00aedbf5f54b17e1ed3a3689729aa3db02d9f3709b05512f7623986ff660a94d3b30845e55787da3e722885a87141e0319e0675c6499093b200",
                "status": "confirmed",
                "block_number": "3304",
                "block_offset": "1",
                "expires_at": null
            }
        }

## Querying for a set of assets [GET /assets{?registrant,asset_ids,pending}]

#### PARAMETERS 

| PARAMETER  | TYPE  | DESCRIPTION  |
|---:|---|---|
| `registrant`  | string <br> *optional* | Filter assets by accountholder registering the asset. |
| `asset_ids`  | string[] <br> *optional* | Return assets matching an array of asset `id`s |
| `pending`  | boolean <br> *optional* | Include assets with asset records pending confirmation in the blockchain. Default: `false`. |

Get all the assets that match the given conditions.
Note: Currently only the first 100 latest assets are returned

+ Parameters

    + registrant: e3iQ86Hdj8owb8xg31QqUqanptPoQLzt2UvXQ5CB2Jf5wyRKLk (string, optional) - Filter bitmarks by asset fingerprint
    + asset_ids: 2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e (string[], optional) - Return assets with these ids
    + pending: true (boolean, optional) - Whether the api should take pending asset into account

+ Request

        + asset_ids: 2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e
        + pending: true

+ Response 200 (application/json)
 
        {
            "asset": {
                "id": "2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e",
                "name": "all rise",
                "fingerprint": "013a13f34c7bd7ddd970c26d8ee6eea8685362554189219f2dc2833e6f5e1347e9d35365ad8bc71023d9d67acbee8060e9da40bac094193353b6546367b85193cc",
                "metadata": {
                "Creator": "ai biet"
                },
                "registrant": "e3iQ86Hdj8owb8xg31QqUqanptPoQLzt2UvXQ5CB2Jf5wyRKLk",
                "signature": "2488af1e00a6a00aedbf5f54b17e1ed3a3689729aa3db02d9f3709b05512f7623986ff660a94d3b30845e55787da3e722885a87141e0319e0675c6499093b200",
                "status": "confirmed",
                "block_number": "3304",
                "block_offset": "1",
                "expires_at": null
            }
        }

+ Request

        + registrant: 2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e
        + pending: true

+ Response 200 (application/json)

        {
            "assets": [
                {
                "id": "a2a880c316c994b73451f3fd0fa3144b54fbae897a012fecd5310e83ebcfeb9d1da96a566aa543665632ddeb75d4b6d540bc9a57162bb6b6495c26d087cdee4a",
                "name": "kim test 024",
                "fingerprint": "0194f2334ced6817c552569c78d0b1ff737bcf8fba8dccbb7563056157340036c1bfeff9bf9648184b5223a197ac901a5deeab6fee1abdfbac73599c339446f3396f9b96da3c17483d1e2888893593d9e9080509e4",
                "metadata": {
                    "description": "kim test 024"
                },
                "registrant": "e4uZbWLdxgGYs8DFrnQQxGuwP7pFMasqpkLXL7uFheJwhEBjoi",
                "signature": "1427f2aced89ca393203a5c7aac7a726a0d78c5de05fb37e132a82d7d34c577cbcd2fe2606b1cedad7629da3b46afd9f074789f42b437d588eae55f4d404510b",
                "status": "confirmed",
                "block_number": "2",
                "block_offset": "1",
                "expires_at": null
                },
                {
                "id": "148165ee98365b6a47c6605bba009214b0e78e67443166b4ac42c56adc7f5373b5c18955fdbbd9d92bc4eaae9f477cb68d754140374d23716764394621195ba9",
                "name": "Vien test dev2 - kid cdd8",
                "fingerprint": "0188beb81dab41b2be09b515e224a01e416afee6473fc69f2386e7878def4653bfb8afb80a77a71be3fcdb852b7e2aeaf977337ca93f75eee0a7218c5e4e3ac27f5f0778d76eb2100206c97497c29c53e4320a818a",
                "metadata": {
                    "description": "\/Users\/bitmark\/Downloads\/images\/21abebbbd93342f0acd43d0f0083cdd8.jpg"
                },
                "registrant": "fpspn8PRuTF5TPYzaf3oDM7w1ZDohiFgqeySabzqiUAMpHBNUy",
                "signature": "2ba7cb5ad96852c7dc80894c462d46b1e56f266bbb877a50d00cc9134cfec6720d39c79df75f1b2ac27bfe5585fa6c894b3e949791a207dd4d29ae0b0dc3c307",
                "status": "confirmed",
                "block_number": "3",
                "block_offset": "1",
                "expires_at": null
                },
                {
                "id": "57518290d09cb6966c5646fa41a7cbd1f6e5f2720c6908ef4410b1e0a2a4aa70533a76445af752dda5d461a7a76bfe8a05df48ad8caf54b2dc26776b1f29d63a",
                "name": "Vien test dev2 - kid dbe copy",
                "fingerprint": "01ed17195de9e9c009847c215c348dca9d4e2a33edca7612d61814092d051d9bd0c62da0e6681692fe3d4739eaa3837befd26ed62aebb5c43a92a59162d3d2bd53bd4462687ff96a65668834bc9207cbbb4c4f5171",
                "metadata": {
                    "description": "\/Users\/bitmark\/Downloads\/images\/8751ee9893c77f31076d63bc177dbe25 copy.jpg"
                },
                "registrant": "fpspn8PRuTF5TPYzaf3oDM7w1ZDohiFgqeySabzqiUAMpHBNUy",
                "signature": "49a7b47f25d4fe2ec92913b5f22e7acfe454feb386fbe0fdb660ec623ab7c970fe37bd14b5ceb8d82054372af19e344ce0188bea385f1ce4d98a7e77bf79b20f",
                "status": "confirmed",
                "block_number": "4",
                "block_offset": "1",
                "expires_at": null
                },
                {
                "id": "3c6e2b0f20fcc7333d1bba3116d76328390cd271243dc2392f640cbba020bcbcb07eae4f7af15909872b416de23fb4d5928d1a7704879cfd0c902928a7458465",
                "name": "kim test 027",
                "fingerprint": "01cf76d120ffbcfe74c50eb429870b623f2fa537e0631c65b9e51471c9302e174baf0793a74431463cc94e77929eb9fd96d0470d7c362a9512aebb981030da3b141a859d7e939f381f9b2b980783b212833d478965",
                "metadata": {
                    "description": "kim test 027"
                },
                "registrant": "e4uZbWLdxgGYs8DFrnQQxGuwP7pFMasqpkLXL7uFheJwhEBjoi",
                "signature": "6e7658eb069b51776f3e5624322b74d787453c924953ebd9fa132f951347f1d866d49cd0569706196171c03223931086a36f7f49d5bff4783f1f2fb9fd114607",
                "status": "confirmed",
                "block_number": "5",
                "block_offset": "1",
                "expires_at": null
                }
            ]
        }



#Group Bitmarks

A **bitmark** is a unique digital property title for a digital asset. A bitmark plus an asset equals a digital property. 

> **digital property = asset + bitmark**

At a technical level, a bitmark is defined as a digitally signed chain consisting of a single issuance record and one or more transfer records. A bitmark is created by submitting an **issuance record** to be verified and recorded in the Bitmark blockchain. This issuance serves as the "head" of the bitmark's chain of ownership. Subsequent transfers of ownership are recorded by submitting **transfer records** for the bitmark. These transfer records establish a permanent chain of ownership by linking back to the previous record in the chain — either to a previous transfer record or the original issuance record. Thus, a bitmark consists of a chain of issuance and transfer records that weaves in and out of different blocks of transactions to create its provenance. The authenticity of each property’s provenance is maintained by continuously verifying this chain of owner signatures.

![bitmark diagram](https://github.com/bitmark-inc/bitmark-core-doc/blob/master/bitmark.png?raw=true)

As an example, consider the figure above, in which Alice issues a bitmark for a specific digital asset. The Bitmark system first uses a cryptographic hashing function to generate a unique fingerprint for the digital asset along with an issuance record for the bitmark which lists Alice as the owner. Once it has been verified by the Bitmark network, this issuance record is aggregated into latest block of the Bitmark blockchain (let’s say block 13). When Alice later wishes to transfer ownership of the property to Bob, Alice creates a transfer record that contains a link back to her previous issuance record, designates Bob as the new owner, and digitally signs the transfer record with her private key. Once this transfer record has been verified by the network to contain an authentic signature from the current owner (Alice), the transfer record is recorded in block 20 of the blockchain, at which point ownership passes to Bob. This method of requiring the current owner to digitally sign ownership transfers creates an incorruptible chain of title for a property. The Bitmark system has been architected to support multiple digital signing methods, including digital signatures that guard against the possibility of future attacks from post-quantum computers.

This section of the Bitmark Core API describes the objects and methods for generating new bitmark issuances and bitmark ownership transfers. 

## Issuing a bitmark [POST /issue]

It will return you a list of transaction id if the request has submmitted to the blockchain.

This issuance record contains

#### PARAMETERS 

| PARAMETER  | TYPE  | DESCRIPTION  |
|---:|---|---|
| `asset`  | string <br> **required** | The `id`value of the corresponding Asset Record. |
| `owner` | string <br> **required** | Public key representing of the account holder issuing the bitmark. |
| `nonce` | uint64 <br> **required** | Distinguishes between different issuances for the same `asset` value. |
| `signature` | binary <br> **required** | binary value (address without checksum) ??? |


#### Creating an issuance record

Issuing new bitmarks is a 3-step process:

1. The binary format of an Issuance Record is packed for signing by concatenating the Issuance Record attribute values in the following order:
    
    1. `varint(0x03)` — binary value prefix that identifies the record as an Issuance Record
    2. `asset` - binary value
    3. `owner` — binary value (address without checksum)
    4. `varint(nonce)` — buffer
2. The issuing account holder must sign the packed record with the account's private key to create a valid `signature`. 
3. A payload is generated by appending the `signature` from Step 2 to the end of the packed Issuance Record from Step 1.

Returns: 

| PARAMETER  | TYPE  | DESCRIPTION  |
|---:|---|---|
| `id` | string <br> **required** | sha3_256 hash of the packed record |

The issue record is returned by the API call `/bitmarks`. Its data is completely as a normal transfer to the issuer, please look at transfer record for more details.

**Signature**
The owner needs to sign the packed record to create a valid signature.

**Payload**
The payload is made by appending the signature after the packed record

**Database record**
The issue records is returned by the API call `/bitmarks`. Its data is completely as a normal transfer to the issuer, please look at transfer record for more details.



+ Request (application/json)

        {
            "assets": [
                {
                    "name": "testcase",
                    "fingerprint": "test_fingerprint",
                    "metadata": "",
                    "registrant": "e1m7c2amjuTYrRf18LyDHContyYo27Vw2PpeKdryWZmasZBnWU",
                    "signature": "68cbccfd732e494b827aadfa7546de73d4f0c3e69ce1d5ff81d100e2fdc05696969f193a024c9f77ae79900252304c84f0ebdffee2f01b117713a58afb006d06"
                }
            ],
            "issues": [
                {
                    "asset": "e3edef121b7dd0e30f389716cae89a1589335d7d8aa9fe3802f8b19f19505077ff13a21f4c3374c1f188dd9fe13fcab39f2690e1fdae54473a850e8dc519e882",
                    "owner": "e1m7c2amjuTYrRf18LyDHContyYo27Vw2PpeKdryWZmasZBnWU",
                    "nonce": 1499245158002,
                    "signature": "d7cfb3f008000bffae32b98df6bacf8b5a068d4d29ebc114666fbf354be1c81725bcfb1124613e4dcfdc9674019b0723c4aebe32d4f3ed246dde19176c111308"
                }
            ]
        }

+ Response 200

    + Body
    
            [
                {
                    "id":"fff75e50fcdef3e674b35a166de6b911f669fdd5c1f4d7d461942f7edbee63aa"
                }
            ]

+ Response 400 (application/json)

    + Body
    
            {
                "message": "missing parameters or containing parameters in an invalid form."
            }
        
        
+ Response 402 (application/json)

    + Body
    
            {
                "message": "not enough of credits"
            }

+ Response 500 (application/json)

    + Body
    
            {
                "message": "unable to connect to a bitmarkd node"
            }





## Transferring a bitmark [POST /transfer]

It will return a transaction id if the request has submmitted to the blockchain.


#### PARAMETERS 

| PARAMETER  | TYPE  | DESCRIPTION  |
|---:|---|---|
| `link` | string <br> **required** | `id` of the previous record in the bitmark. |
| `owner` | string <br> **required** | Public key for the accountholder receiving the bitmark transfer. |
| `signature` | binary <br> **required** | binary value (address without checksum) ??? |
| `payment` | string <br> *optional* |     - currency code (bitcoin is `0x01`) - payment address (string)  - amount  |

ans
#### Creating a transfer record

Transfering bitmarks is a 3-step process:

1. The binary format of an Issuance Record is packed for signing by concatenating the Issuance Record attribute values in the following order:
    
    1. `varint(0x04)` — binary value (the prefix `0x04` identifies the record as a transfer record)
    2. `link` - binary value
    3. `owner` — binary value (address without checksum)
    4. `payment` — If there is a payment: varint value of `0x01`; if not: varint value of `0x00`
    - `varint(currency_code)`
    - `payment address` — string value
    - `varint(amount)`
2. The issuing account holder must sign the packed record with the account's private key to create a valid `signature`. 
3. A payload is generated by appending the `signature` from Step 2 to the end of the packed Issuance Record from Step 1.

The issue records is returned by the API call `/bitmarks`. Its data is completely as a normal transfer to the issuer, please look at transfer record for more details.

**Signature**
The owner needs to sign the packed record to create a valid signature.

**Payload**
The payload is made by concatenating the signature after the packed record

**Database record**
The transfer records is returned by the API call `/bitmarks`. It has more attributes to expose more information about the transfer as bellow:

(TBA)

+ Request (application/json)

        {
            transfer: {
                    "link": "6776599a5fd4f2ade1ca87ee5fffd0295bb69b1969ffab1ec042a5f71ef74209",
                    "owner": "fqN6WnjUaekfrqBvvmsjVskoqXnhJ632xJPHzdSgReC6bhZGuP",
                    "signature": "e14642c9b9f0e1409ad2a0b9a248bf356ee9a9854a4c4f602d3de8daccf5cd11ee270c945c7d3bb58a3fc2858c109bdb9ad31914d2e1a1867383fdcd1f300f0e"
            }   
        }

+ Response 200

    + Body
    
            [
                {
                    "txid":"fff75e50fcdef3e674b35a166de6b911f669fdd5c1f4d7d461942f7edbee63aa"
                }
            ]

+ Response 400 (application/json)

    + Body
    
            {
                "message": "missing parameters or containing parameters in an invalid form."
            }

+ Response 402 (application/json)

    + Body
    
            {
                "message": "not enough of credits"
            }

+ Response 500 (application/json)

    + Body
    
            {
                "message": "unable to connect to a bitmarkd node"
            }


## Querying for a specific bitmark [GET /bitmarks/{bitmark_id}{?asset,provenance,pending}]

Queries the Bitmark blockchain ... 

#### PARAMETERS

| PARAMETER  | TYPE  | DESCRIPTION  |
|---:|---|---|
| `bitmark_id`  | string <br> **required** | TXID of the bitmark in the form of hex string. |
| `provenance`  | boolean <br> *optional* | Includes the bitmark's provenance. Default: `false`. |
| `asset`  | boolean <br> *optional* | Includes the bitmark's corresponding asset record. Default: `false`. |
| `pending`  | boolean <br> *optional* | Whether to take pending transaction into account. Default value: `false`. |



+ Parameters

    + bitmark_id: ebb2c6d8ec37a50b1f755da14d3874e8fd3510678665da27391f063387ad4c03 (string, required) - TXID of the bitmark in the form of hex string
    + provenance: true (boolean, optional) - Ask the server to also return the bitmark provenance
        + Default: false
    + asset: true (boolean, optional) - Option parameter to return the corresponding asset record.
        + Default: false
    + pending: true (boolean, optional) - Option parameter to tell the server whether to take pending transactions into account

+ Request

        + bitmark_id: ebb2c6d8ec37a50b1f755da14d3874e8fd3510678665da27391f063387ad4c03
        + provenance: true
        + asset: true
        + pending: true

+ Response 200 (application/json)

        {  
            "bitmark":{  
                "head_id":"ebb2c6d8ec37a50b1f755da14d3874e8fd3510678665da27391f063387ad4c03",
                "owner":"eA3SzibojnTF34YAua8MyYDoRmVhAUzFxuQiPuVvYrt9XMKak1",
                "asset_id":"2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e",
                "id":"ebb2c6d8ec37a50b1f755da14d3874e8fd3510678665da27391f063387ad4c03",
                "issuer":"eA3SzibojnTF34YAua8MyYDoRmVhAUzFxuQiPuVvYrt9XMKak1",
                "issued_at":"2017-06-12T09:54:59.000000Z",
                "head":"head",
                "status":"confirmed",
                "block_number":3690,
                "offset":32713,
                "created_at":"2017-06-12T09:54:59.000000Z",
                "provenance":[  
                    {  
                        "tx_id":"ebb2c6d8ec37a50b1f755da14d3874e8fd3510678665da27391f063387ad4c03",
                        "owner":"eA3SzibojnTF34YAua8MyYDoRmVhAUzFxuQiPuVvYrt9XMKak1",
                        "status":"confirmed",
                        "created_at":"2017-06-12T09:54:59.000000Z"
                    }
                ]
            },
            "asset":{  
                "id":"2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e",
                "name":"all rise",
                "fingerprint":"013a13f34c7bd7ddd970c26d8ee6eea8685362554189219f2dc2833e6f5e1347e9d35365ad8bc71023d9d67acbee8060e9da40bac094193353b6546367b85193cc",
                "metadata":{  
                    "Creator":"ai biet"
                },
                "registrant":"e3iQ86Hdj8owb8xg31QqUqanptPoQLzt2UvXQ5CB2Jf5wyRKLk",
                "status":"confirmed",
                "block_number":3304,
                "block_offset":1,
                "expires_at":null,
                "offset":814
            }
        }
 
## Querying for a set of bitmarks [GET /bitmarks{?asset_id,issuer,owner,ownwer_sent,asset,pending,offset,direction,limit}]

Queries the Bitmark blockchain ... 


Get all the bitmarks that changed in a specific range of time that match the given conditions.

#### PARAMETERS

| PARAMETER  | TYPE  | DESCRIPTION  |
|---:|---|---|
| `asset_id`  | string <br> *optional* | Filters bitmarks for those issued for a specific asset. |
| `issuer`  | string <br> *optional* | Filters bitmarks for those issued by a specific account holder's public key. |
| `owner`  | boolean <br> *optional* | Filters bitmarks for those currently owned by a specific account holder's public key. |
| `owner_sent`  | boolean <br> *optional* | Includes bitmarks which are sent from this account. |
| `asset`  | boolean <br> *optional* | Includes bitmarks' corresponding asset records. Default value: `false`. |
| `pending`  | boolean <br> *optional* | Whether to take pending transactions into account. Default value: `false`. |
| `direction`  | enum[string] <br> *optional* | Specify which direction to return the bitmarks. Possible values: `up`, `down`.  Default value: `down`. |
| `offset`  | string <br> *optional* | Offset from which the bitmarks are returned. |
| `limit`  | number <br> *optional* | Optional parameter to limit the number of bitmarks returned for the specified parameters. Maximum value: `100`. |


+ Parameters

    + asset_id: 2f667c16f2d17bfa28fe32d6eb8a4d306702fc41f5086d0ce8b214235f00ab2858f048ef19efeccd5046e3ce8b19c6300ca9bad3f493416dbcf2d65de470086e (string, optional) - Filter bitmarks by asset id
    + issuer: eA3SzibojnTF34YAua8MyYDoRmVhAUzFxuQiPuVvYrt9XMKak1 (string, optional) - Filter bitmarks by issuer
    + owner: eA3SzibojnTF34YAua8MyYDoRmVhAUzFxuQiPuVvYrt9XMKak1 (string, optional) - Filter bitmarks by owner
    + asset: true (string, optional) - Whether the api should return asset record
        + Default: false
    + pending: true (boolean, optional) - Whether the api should take pending bitmark into account
        + Default: false
    + direction: up (enum[string], optional)
        + Default: down
        + Members
            + up
            + down
    + offset: `139356` (number, optional) - The offset from which the bitmarks are returned. E.g: To get a list of bitmarks that an account is owning, you first make the requestion with omitting offset. After getting a list of bitmarks, take the last bitmark offset `139356`, and then call the API again with this offset, you can get the next batch of bitmarks.
    + limit: 100 {number, optional) - limit the items returned, maximum is 100

+ Request

        + owner: fbfPqtPTaYGf9NiCAhNY8yBeUw1tDQaGMGebYA4bABeT6ywuoY,
        + asset: true
        + direction: up
        + offset: 139356


+ Response 200 (application/json)

        {  
            "bitmarks":[
                {  
                    "head_id":"30bd3a377eb00b663f37c43268781b420b5aab68ffb595053408e3508e674f6f",
                    "owner":"f1VzSvQ9q6KAUPVRUk8eKXxndM6mDFoRzVjA542sDsdfoWQZ97",
                    "asset_id":"be08510b9d6700d949c136ff285a6b20362a568ec38b9ba138ccdfb4a1cdf04a575c590eec4c7c64a89a512da06164779c1f7e4a8e338748e52a659f018be857",
                    "id":"30bd3a377eb00b663f37c43268781b420b5aab68ffb595053408e3508e674f6f",
                    "issuer":"f1VzSvQ9q6KAUPVRUk8eKXxndM6mDFoRzVjA542sDsdfoWQZ97",
                    "issued_at":"2017-08-15T04:26:38.000000Z",
                    "head":"head",
                    "status":"confirmed",
                    "block_number":5272,
                    "offset":139360,
                    "created_at":"2017-08-15T04:26:38.000000Z"
                },
                {  
                    "head_id":"9a75ac293b0dfc2cd805c8eb28e157ee3f2a9e98120f4bdf15f6534b5ce81e2d",
                    "owner":"f1VzSvQ9q6KAUPVRUk8eKXxndM6mDFoRzVjA542sDsdfoWQZ97",
                    "asset_id":"be08510b9d6700d949c136ff285a6b20362a568ec38b9ba138ccdfb4a1cdf04a575c590eec4c7c64a89a512da06164779c1f7e4a8e338748e52a659f018be857",
                    "id":"9a75ac293b0dfc2cd805c8eb28e157ee3f2a9e98120f4bdf15f6534b5ce81e2d",
                    "issuer":"f1VzSvQ9q6KAUPVRUk8eKXxndM6mDFoRzVjA542sDsdfoWQZ97",
                    "issued_at":"2017-08-15T04:24:58.000000Z",
                    "head":"head",
                    "status":"confirmed",
                    "block_number":5271,
                    "offset":139358,
                    "created_at":"2017-08-15T04:24:58.000000Z"
                }
            ],
            "assets":[  
                {  
                    "id":"be08510b9d6700d949c136ff285a6b20362a568ec38b9ba138ccdfb4a1cdf04a575c590eec4c7c64a89a512da06164779c1f7e4a8e338748e52a659f018be857",
                    "name":"code",
                    "fingerprint":"015f018900e4d347a8620dd47dc35856007413be8257c0d7d12ede3a40439f568dd3b1fc49739740dfb11a237d032922ca03d10909d7cd0a59b5c79e1047fac061",
                    "metadata":{  
                        "Contributor":"1"
                    },
                    "registrant":"f1VzSvQ9q6KAUPVRUk8eKXxndM6mDFoRzVjA542sDsdfoWQZ97",
                    "status":"confirmed",
                    "block_number":5269,
                    "block_offset":1,
                    "expires_at":null,
                    "offset":2301
                }
            ]
        }